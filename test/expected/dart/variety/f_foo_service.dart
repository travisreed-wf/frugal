// Autogenerated by Frugal Compiler (2.18.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING



import 'dart:async';

import 'dart:typed_data' show Uint8List;
import 'package:logging/logging.dart' as logging;
import 'package:thrift/thrift.dart' as thrift;
import 'package:frugal/frugal.dart' as frugal;

import 'package:actual_base_dart/actual_base_dart.dart' as t_actual_base_dart;
import 'package:validStructs/validStructs.dart' as t_validStructs;
import 'package:ValidTypes/ValidTypes.dart' as t_ValidTypes;
import 'package:subdir_include_ns/subdir_include_ns.dart' as t_subdir_include_ns;
import 'package:variety/variety.dart' as t_variety;


/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
abstract class FFoo extends t_actual_base_dart.FBaseFoo {

  /// Ping the server.
  /// Deprecated: don't use this; use "something else"
  @deprecated
  Future ping(frugal.FContext ctx);

  /// Blah the server.
  Future<int> blah(frugal.FContext ctx, int num, String str, t_variety.Event event);

  /// oneway methods don't receive a response from the server.
  Future oneWay(frugal.FContext ctx, int id, Map<int, String> req);

  Future<Uint8List> bin_method(frugal.FContext ctx, Uint8List bin, String str);

  Future<int> param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num);

  Future<List<int>> underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type);

  Future<t_validStructs.Thing> getThing(frugal.FContext ctx);

  Future<int> getMyInt(frugal.FContext ctx);

  Future<t_subdir_include_ns.A> use_subdir_struct(frugal.FContext ctx, t_subdir_include_ns.A a);
}

/// This is a thrift service. Frugal will generate bindings that include
/// a frugal Context for each service call.
class FFooClient extends t_actual_base_dart.FBaseFooClient implements FFoo {
  static final logging.Logger _frugalLog = new logging.Logger('Foo');
  Map<String, frugal.FMethod> _methods;

  FFooClient(frugal.FServiceProvider provider, [List<frugal.Middleware> middleware])
      : super(provider, middleware) {
    _transport = provider.transport;
    _protocolFactory = provider.protocolFactory;
    var combined = middleware ?? [];
    combined.addAll(provider.middleware);
    this._methods = {};
    this._methods['ping'] = new frugal.FMethod(this._ping, 'Foo', 'ping', combined);
    this._methods['blah'] = new frugal.FMethod(this._blah, 'Foo', 'blah', combined);
    this._methods['oneWay'] = new frugal.FMethod(this._oneWay, 'Foo', 'oneWay', combined);
    this._methods['bin_method'] = new frugal.FMethod(this._bin_method, 'Foo', 'bin_method', combined);
    this._methods['param_modifiers'] = new frugal.FMethod(this._param_modifiers, 'Foo', 'param_modifiers', combined);
    this._methods['underlying_types_test'] = new frugal.FMethod(this._underlying_types_test, 'Foo', 'underlying_types_test', combined);
    this._methods['getThing'] = new frugal.FMethod(this._getThing, 'Foo', 'getThing', combined);
    this._methods['getMyInt'] = new frugal.FMethod(this._getMyInt, 'Foo', 'getMyInt', combined);
    this._methods['use_subdir_struct'] = new frugal.FMethod(this._use_subdir_struct, 'Foo', 'use_subdir_struct', combined);
  }

  frugal.FTransport _transport;
  frugal.FProtocolFactory _protocolFactory;

  /// Ping the server.
  /// Deprecated: don't use this; use "something else"
  @deprecated
  Future ping(frugal.FContext ctx) {
    _frugalLog.warning("Call to deprecated function 'Foo.ping'");
    return this._methods['ping']([ctx]) as Future;
  }

  Future _ping(frugal.FContext ctx) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("ping", thrift.TMessageType.CALL, 0));
    Ping_args args = new Ping_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    Ping_result result = new Ping_result();
    result.read(iprot);
    iprot.readMessageEnd();
  }
  /// Blah the server.
  Future<int> blah(frugal.FContext ctx, int num, String str, t_variety.Event event) {
    return this._methods['blah']([ctx, num, str, event]) as Future<int>;
  }

  Future<int> _blah(frugal.FContext ctx, int num, String str, t_variety.Event event) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("blah", thrift.TMessageType.CALL, 0));
    blah_args args = new blah_args();
    args.num = num;
    args.str = str;
    args.event = event;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    blah_result result = new blah_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.awe != null) {
      throw result.awe;
    }
    if (result.api != null) {
      throw result.api;
    }
    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "blah failed: unknown result"
    );
  }
  /// oneway methods don't receive a response from the server.
  Future oneWay(frugal.FContext ctx, int id, Map<int, String> req) {
    return this._methods['oneWay']([ctx, id, req]) as Future;
  }

  Future _oneWay(frugal.FContext ctx, int id, Map<int, String> req) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("oneWay", thrift.TMessageType.ONEWAY, 0));
    oneWay_args args = new oneWay_args();
    args.id = id;
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();
    await _transport.oneway(ctx, memoryBuffer.writeBytes);
  }

  Future<Uint8List> bin_method(frugal.FContext ctx, Uint8List bin, String str) {
    return this._methods['bin_method']([ctx, bin, str]) as Future<Uint8List>;
  }

  Future<Uint8List> _bin_method(frugal.FContext ctx, Uint8List bin, String str) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("bin_method", thrift.TMessageType.CALL, 0));
    bin_method_args args = new bin_method_args();
    args.bin = bin;
    args.str = str;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    bin_method_result result = new bin_method_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.api != null) {
      throw result.api;
    }
    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "bin_method failed: unknown result"
    );
  }
  Future<int> param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num) {
    return this._methods['param_modifiers']([ctx, opt_num, default_num, req_num]) as Future<int>;
  }

  Future<int> _param_modifiers(frugal.FContext ctx, int opt_num, int default_num, int req_num) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("param_modifiers", thrift.TMessageType.CALL, 0));
    param_modifiers_args args = new param_modifiers_args();
    args.opt_num = opt_num;
    args.default_num = default_num;
    args.req_num = req_num;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    param_modifiers_result result = new param_modifiers_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "param_modifiers failed: unknown result"
    );
  }
  Future<List<int>> underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type) {
    return this._methods['underlying_types_test']([ctx, list_type, set_type]) as Future<List<int>>;
  }

  Future<List<int>> _underlying_types_test(frugal.FContext ctx, List<int> list_type, Set<int> set_type) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("underlying_types_test", thrift.TMessageType.CALL, 0));
    underlying_types_test_args args = new underlying_types_test_args();
    args.list_type = list_type;
    args.set_type = set_type;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    underlying_types_test_result result = new underlying_types_test_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "underlying_types_test failed: unknown result"
    );
  }
  Future<t_validStructs.Thing> getThing(frugal.FContext ctx) {
    return this._methods['getThing']([ctx]) as Future<t_validStructs.Thing>;
  }

  Future<t_validStructs.Thing> _getThing(frugal.FContext ctx) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("getThing", thrift.TMessageType.CALL, 0));
    getThing_args args = new getThing_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    getThing_result result = new getThing_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "getThing failed: unknown result"
    );
  }
  Future<int> getMyInt(frugal.FContext ctx) {
    return this._methods['getMyInt']([ctx]) as Future<int>;
  }

  Future<int> _getMyInt(frugal.FContext ctx) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("getMyInt", thrift.TMessageType.CALL, 0));
    getMyInt_args args = new getMyInt_args();
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    getMyInt_result result = new getMyInt_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "getMyInt failed: unknown result"
    );
  }
  Future<t_subdir_include_ns.A> use_subdir_struct(frugal.FContext ctx, t_subdir_include_ns.A a) {
    return this._methods['use_subdir_struct']([ctx, a]) as Future<t_subdir_include_ns.A>;
  }

  Future<t_subdir_include_ns.A> _use_subdir_struct(frugal.FContext ctx, t_subdir_include_ns.A a) async {
    var memoryBuffer = new frugal.TMemoryOutputBuffer(_transport.requestSizeLimit);
    var oprot = _protocolFactory.getProtocol(memoryBuffer);
    oprot.writeRequestHeader(ctx);
    oprot.writeMessageBegin(new thrift.TMessage("use_subdir_struct", thrift.TMessageType.CALL, 0));
    use_subdir_struct_args args = new use_subdir_struct_args();
    args.a = a;
    args.write(oprot);
    oprot.writeMessageEnd();
    var response = await _transport.request(ctx, memoryBuffer.writeBytes);

    var iprot = _protocolFactory.getProtocol(response);
    iprot.readResponseHeader(ctx);
    thrift.TMessage msg = iprot.readMessageBegin();
    if (msg.type == thrift.TMessageType.EXCEPTION) {
      thrift.TApplicationError error = thrift.TApplicationError.read(iprot);
      iprot.readMessageEnd();
      if (error.type == frugal.FrugalTTransportErrorType.REQUEST_TOO_LARGE) {
        throw new thrift.TTransportError(frugal.FrugalTTransportErrorType.RESPONSE_TOO_LARGE, error.message);
      }
      throw error;
    }

    use_subdir_struct_result result = new use_subdir_struct_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    throw new thrift.TApplicationError(
      frugal.FrugalTApplicationErrorType.MISSING_RESULT, "use_subdir_struct failed: unknown result"
    );
  }
}

class Ping_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("Ping_args");



  Ping_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("Ping_args(");

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is Ping_args)) {
      return false;
    }
    return true;
  }

  Ping_args clone() {
    return new Ping_args();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class Ping_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("Ping_result");



  Ping_result() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("Ping_result(");

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is Ping_result)) {
      return false;
    }
    return true;
  }

  Ping_result clone() {
    return new Ping_result();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class blah_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("blah_args");
  static final thrift.TField _NUM_FIELD_DESC = new thrift.TField("num", thrift.TType.I32, 1);
  static final thrift.TField _STR_FIELD_DESC = new thrift.TField("Str", thrift.TType.STRING, 2);
  static final thrift.TField _EVENT_FIELD_DESC = new thrift.TField("event", thrift.TType.STRUCT, 3);

  int _num = 0;
  static const int NUM = 1;
  String _str;
  static const int STR = 2;
  t_variety.Event _event;
  static const int EVENT = 3;

  bool __isset_num = false;

  blah_args() {
  }

  int get num => this._num;

  set num(int num) {
    this._num = num;
    this.__isset_num = true;
  }

  bool isSetNum() => this.__isset_num;

  unsetNum() {
    this.__isset_num = false;
  }

  String get str => this._str;

  set str(String str) {
    this._str = str;
  }

  bool isSetStr() => this.str != null;

  unsetStr() {
    this.str = null;
  }

  t_variety.Event get event => this._event;

  set event(t_variety.Event event) {
    this._event = event;
  }

  bool isSetEvent() => this.event != null;

  unsetEvent() {
    this.event = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case NUM:
        return this.num;
      case STR:
        return this.str;
      case EVENT:
        return this.event;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case NUM:
        if(value == null) {
          unsetNum();
        } else {
          this.num = value as int;
        }
        break;

      case STR:
        if(value == null) {
          unsetStr();
        } else {
          this.str = value as String;
        }
        break;

      case EVENT:
        if(value == null) {
          unsetEvent();
        } else {
          this.event = value as t_variety.Event;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case NUM:
        return isSetNum();
      case STR:
        return isSetStr();
      case EVENT:
        return isSetEvent();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case NUM:
          if(field.type == thrift.TType.I32) {
            num = iprot.readI32();
            this.__isset_num = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STR:
          if(field.type == thrift.TType.STRING) {
            str = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EVENT:
          if(field.type == thrift.TType.STRUCT) {
            event = new t_variety.Event();
            event.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_NUM_FIELD_DESC);
    oprot.writeI32(num);
    oprot.writeFieldEnd();
    if(this.str != null) {
      oprot.writeFieldBegin(_STR_FIELD_DESC);
      oprot.writeString(str);
      oprot.writeFieldEnd();
    }
    if(this.event != null) {
      oprot.writeFieldBegin(_EVENT_FIELD_DESC);
      event.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blah_args(");

    ret.write("num:");
    ret.write(this.num);

    ret.write(", ");
    ret.write("str:");
    if(this.str == null) {
      ret.write("null");
    } else {
      ret.write(this.str);
    }

    ret.write(", ");
    ret.write("event:");
    if(this.event == null) {
      ret.write("null");
    } else {
      ret.write(this.event);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is blah_args)) {
      return false;
    }
    blah_args other = o as blah_args;
    return this.num == other.num
      && this.str == other.str
      && this.event == other.event;
  }

  blah_args clone({
    int num: null,
    String str: null,
    t_variety.Event event: null,
  }) {
    return new blah_args()
      ..num = num ?? this.num
      ..str = str ?? this.str
      ..event = event ?? this.event;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class blah_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("blah_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.I64, 0);
  static final thrift.TField _AWE_FIELD_DESC = new thrift.TField("awe", thrift.TType.STRUCT, 1);
  static final thrift.TField _API_FIELD_DESC = new thrift.TField("api", thrift.TType.STRUCT, 2);

  int _success;
  static const int SUCCESS = 0;
  t_variety.AwesomeException _awe;
  static const int AWE = 1;
  t_actual_base_dart.api_exception _api;
  static const int API = 2;

  bool __isset_success = false;

  blah_result() {
  }

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  t_variety.AwesomeException get awe => this._awe;

  set awe(t_variety.AwesomeException awe) {
    this._awe = awe;
  }

  bool isSetAwe() => this.awe != null;

  unsetAwe() {
    this.awe = null;
  }

  t_actual_base_dart.api_exception get api => this._api;

  set api(t_actual_base_dart.api_exception api) {
    this._api = api;
  }

  bool isSetApi() => this.api != null;

  unsetApi() {
    this.api = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case AWE:
        return this.awe;
      case API:
        return this.api;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      case AWE:
        if(value == null) {
          unsetAwe();
        } else {
          this.awe = value as t_variety.AwesomeException;
        }
        break;

      case API:
        if(value == null) {
          unsetApi();
        } else {
          this.api = value as t_actual_base_dart.api_exception;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case AWE:
        return isSetAwe();
      case API:
        return isSetApi();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.I64) {
            success = iprot.readI64();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AWE:
          if(field.type == thrift.TType.STRUCT) {
            awe = new t_variety.AwesomeException();
            awe.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case API:
          if(field.type == thrift.TType.STRUCT) {
            api = new t_actual_base_dart.api_exception();
            api.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(success);
      oprot.writeFieldEnd();
    }
    if(isSetAwe() && this.awe != null) {
      oprot.writeFieldBegin(_AWE_FIELD_DESC);
      awe.write(oprot);
      oprot.writeFieldEnd();
    }
    if(isSetApi() && this.api != null) {
      oprot.writeFieldBegin(_API_FIELD_DESC);
      api.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("blah_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      ret.write(this.success);
    }

    if(isSetAwe()) {
      ret.write(", ");
      ret.write("awe:");
      if(this.awe == null) {
        ret.write("null");
      } else {
        ret.write(this.awe);
      }
    }

    if(isSetApi()) {
      ret.write(", ");
      ret.write("api:");
      if(this.api == null) {
        ret.write("null");
      } else {
        ret.write(this.api);
      }
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is blah_result)) {
      return false;
    }
    blah_result other = o as blah_result;
    return this.success == other.success
      && this.awe == other.awe
      && this.api == other.api;
  }

  blah_result clone({
    int success: null,
    t_variety.AwesomeException awe: null,
    t_actual_base_dart.api_exception api: null,
  }) {
    return new blah_result()
      ..success = success ?? this.success
      ..awe = awe ?? this.awe
      ..api = api ?? this.api;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class oneWay_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("oneWay_args");
  static final thrift.TField _ID_FIELD_DESC = new thrift.TField("id", thrift.TType.I64, 1);
  static final thrift.TField _REQ_FIELD_DESC = new thrift.TField("req", thrift.TType.MAP, 2);

  int _id = 0;
  static const int ID = 1;
  Map<int, String> _req;
  static const int REQ = 2;

  bool __isset_id = false;

  oneWay_args() {
  }

  int get id => this._id;

  set id(int id) {
    this._id = id;
    this.__isset_id = true;
  }

  bool isSetId() => this.__isset_id;

  unsetId() {
    this.__isset_id = false;
  }

  Map<int, String> get req => this._req;

  set req(Map<int, String> req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case ID:
        return this.id;
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case ID:
        if(value == null) {
          unsetId();
        } else {
          this.id = value as int;
        }
        break;

      case REQ:
        if(value == null) {
          unsetReq();
        } else {
          this.req = value as Map<int, String>;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case ID:
        return isSetId();
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case ID:
          if(field.type == thrift.TType.I64) {
            id = iprot.readI64();
            this.__isset_id = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REQ:
          if(field.type == thrift.TType.MAP) {
            thrift.TMap elem55 = iprot.readMapBegin();
            req = new Map<int, String>();
            for(int elem57 = 0; elem57 < elem55.length; ++elem57) {
              int elem58 = iprot.readI32();
              String elem56 = iprot.readString();
              req[elem58] = elem56;
            }
            iprot.readMapEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_ID_FIELD_DESC);
    oprot.writeI64(id);
    oprot.writeFieldEnd();
    if(this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      oprot.writeMapBegin(new thrift.TMap(thrift.TType.I32, thrift.TType.STRING, req.length));
      for(var elem59 in req.keys) {
        oprot.writeI32(elem59);
        oprot.writeString(req[elem59]);
      }
      oprot.writeMapEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("oneWay_args(");

    ret.write("id:");
    ret.write(this.id);

    ret.write(", ");
    ret.write("req:");
    if(this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is oneWay_args)) {
      return false;
    }
    oneWay_args other = o as oneWay_args;
    return this.id == other.id
      && this.req == other.req;
  }

  oneWay_args clone({
    int id: null,
    Map<int, String> req: null,
  }) {
    return new oneWay_args()
      ..id = id ?? this.id
      ..req = req ?? this.req;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class bin_method_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("bin_method_args");
  static final thrift.TField _BIN_FIELD_DESC = new thrift.TField("bin", thrift.TType.STRING, 1);
  static final thrift.TField _STR_FIELD_DESC = new thrift.TField("Str", thrift.TType.STRING, 2);

  Uint8List _bin;
  static const int BIN = 1;
  String _str;
  static const int STR = 2;


  bin_method_args() {
  }

  Uint8List get bin => this._bin;

  set bin(Uint8List bin) {
    this._bin = bin;
  }

  bool isSetBin() => this.bin != null;

  unsetBin() {
    this.bin = null;
  }

  String get str => this._str;

  set str(String str) {
    this._str = str;
  }

  bool isSetStr() => this.str != null;

  unsetStr() {
    this.str = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case BIN:
        return this.bin;
      case STR:
        return this.str;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case BIN:
        if(value == null) {
          unsetBin();
        } else {
          this.bin = value as Uint8List;
        }
        break;

      case STR:
        if(value == null) {
          unsetStr();
        } else {
          this.str = value as String;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case BIN:
        return isSetBin();
      case STR:
        return isSetStr();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case BIN:
          if(field.type == thrift.TType.STRING) {
            bin = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case STR:
          if(field.type == thrift.TType.STRING) {
            str = iprot.readString();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(this.bin != null) {
      oprot.writeFieldBegin(_BIN_FIELD_DESC);
      oprot.writeBinary(bin);
      oprot.writeFieldEnd();
    }
    if(this.str != null) {
      oprot.writeFieldBegin(_STR_FIELD_DESC);
      oprot.writeString(str);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("bin_method_args(");

    ret.write("bin:");
    if(this.bin == null) {
      ret.write("null");
    } else {
      ret.write("BINARY");
    }

    ret.write(", ");
    ret.write("str:");
    if(this.str == null) {
      ret.write("null");
    } else {
      ret.write(this.str);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is bin_method_args)) {
      return false;
    }
    bin_method_args other = o as bin_method_args;
    return this.bin == other.bin
      && this.str == other.str;
  }

  bin_method_args clone({
    Uint8List bin: null,
    String str: null,
  }) {
    return new bin_method_args()
      ..bin = bin ?? this.bin
      ..str = str ?? this.str;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class bin_method_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("bin_method_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.STRING, 0);
  static final thrift.TField _API_FIELD_DESC = new thrift.TField("api", thrift.TType.STRUCT, 1);

  Uint8List _success;
  static const int SUCCESS = 0;
  t_actual_base_dart.api_exception _api;
  static const int API = 1;


  bin_method_result() {
  }

  Uint8List get success => this._success;

  set success(Uint8List success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  t_actual_base_dart.api_exception get api => this._api;

  set api(t_actual_base_dart.api_exception api) {
    this._api = api;
  }

  bool isSetApi() => this.api != null;

  unsetApi() {
    this.api = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case API:
        return this.api;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as Uint8List;
        }
        break;

      case API:
        if(value == null) {
          unsetApi();
        } else {
          this.api = value as t_actual_base_dart.api_exception;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case API:
        return isSetApi();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.STRING) {
            success = iprot.readBinary();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case API:
          if(field.type == thrift.TType.STRUCT) {
            api = new t_actual_base_dart.api_exception();
            api.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeBinary(success);
      oprot.writeFieldEnd();
    }
    if(isSetApi() && this.api != null) {
      oprot.writeFieldBegin(_API_FIELD_DESC);
      api.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("bin_method_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      if(this.success == null) {
        ret.write("null");
      } else {
        ret.write("BINARY");
      }
    }

    if(isSetApi()) {
      ret.write(", ");
      ret.write("api:");
      if(this.api == null) {
        ret.write("null");
      } else {
        ret.write(this.api);
      }
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is bin_method_result)) {
      return false;
    }
    bin_method_result other = o as bin_method_result;
    return this.success == other.success
      && this.api == other.api;
  }

  bin_method_result clone({
    Uint8List success: null,
    t_actual_base_dart.api_exception api: null,
  }) {
    return new bin_method_result()
      ..success = success ?? this.success
      ..api = api ?? this.api;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class param_modifiers_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("param_modifiers_args");
  static final thrift.TField _OPT_NUM_FIELD_DESC = new thrift.TField("opt_num", thrift.TType.I32, 1);
  static final thrift.TField _DEFAULT_NUM_FIELD_DESC = new thrift.TField("default_num", thrift.TType.I32, 2);
  static final thrift.TField _REQ_NUM_FIELD_DESC = new thrift.TField("req_num", thrift.TType.I32, 3);

  int _opt_num = 0;
  static const int OPT_NUM = 1;
  int _default_num = 0;
  static const int DEFAULT_NUM = 2;
  int _req_num = 0;
  static const int REQ_NUM = 3;

  bool __isset_opt_num = false;
  bool __isset_default_num = false;
  bool __isset_req_num = false;

  param_modifiers_args() {
  }

  int get opt_num => this._opt_num;

  set opt_num(int opt_num) {
    this._opt_num = opt_num;
    this.__isset_opt_num = true;
  }

  bool isSetOpt_num() => this.__isset_opt_num;

  unsetOpt_num() {
    this.__isset_opt_num = false;
  }

  int get default_num => this._default_num;

  set default_num(int default_num) {
    this._default_num = default_num;
    this.__isset_default_num = true;
  }

  bool isSetDefault_num() => this.__isset_default_num;

  unsetDefault_num() {
    this.__isset_default_num = false;
  }

  int get req_num => this._req_num;

  set req_num(int req_num) {
    this._req_num = req_num;
    this.__isset_req_num = true;
  }

  bool isSetReq_num() => this.__isset_req_num;

  unsetReq_num() {
    this.__isset_req_num = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case OPT_NUM:
        return this.opt_num;
      case DEFAULT_NUM:
        return this.default_num;
      case REQ_NUM:
        return this.req_num;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case OPT_NUM:
        if(value == null) {
          unsetOpt_num();
        } else {
          this.opt_num = value as int;
        }
        break;

      case DEFAULT_NUM:
        if(value == null) {
          unsetDefault_num();
        } else {
          this.default_num = value as int;
        }
        break;

      case REQ_NUM:
        if(value == null) {
          unsetReq_num();
        } else {
          this.req_num = value as int;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case OPT_NUM:
        return isSetOpt_num();
      case DEFAULT_NUM:
        return isSetDefault_num();
      case REQ_NUM:
        return isSetReq_num();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case OPT_NUM:
          if(field.type == thrift.TType.I32) {
            opt_num = iprot.readI32();
            this.__isset_opt_num = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEFAULT_NUM:
          if(field.type == thrift.TType.I32) {
            default_num = iprot.readI32();
            this.__isset_default_num = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case REQ_NUM:
          if(field.type == thrift.TType.I32) {
            req_num = iprot.readI32();
            this.__isset_req_num = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    if(!__isset_req_num) {
      throw new thrift.TProtocolError(thrift.TProtocolErrorType.UNKNOWN, "Required field 'req_num' was not present in struct param_modifiers_args");
    }
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldBegin(_OPT_NUM_FIELD_DESC);
    oprot.writeI32(opt_num);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_DEFAULT_NUM_FIELD_DESC);
    oprot.writeI32(default_num);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_REQ_NUM_FIELD_DESC);
    oprot.writeI32(req_num);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("param_modifiers_args(");

    ret.write("opt_num:");
    ret.write(this.opt_num);

    ret.write(", ");
    ret.write("default_num:");
    ret.write(this.default_num);

    ret.write(", ");
    ret.write("req_num:");
    ret.write(this.req_num);

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is param_modifiers_args)) {
      return false;
    }
    param_modifiers_args other = o as param_modifiers_args;
    return this.opt_num == other.opt_num
      && this.default_num == other.default_num
      && this.req_num == other.req_num;
  }

  param_modifiers_args clone({
    int opt_num: null,
    int default_num: null,
    int req_num: null,
  }) {
    return new param_modifiers_args()
      ..opt_num = opt_num ?? this.opt_num
      ..default_num = default_num ?? this.default_num
      ..req_num = req_num ?? this.req_num;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class param_modifiers_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("param_modifiers_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.I64, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  param_modifiers_result() {
  }

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.I64) {
            success = iprot.readI64();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI64(success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("param_modifiers_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is param_modifiers_result)) {
      return false;
    }
    param_modifiers_result other = o as param_modifiers_result;
    return this.success == other.success;
  }

  param_modifiers_result clone({
    int success: null,
  }) {
    return new param_modifiers_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class underlying_types_test_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("underlying_types_test_args");
  static final thrift.TField _LIST_TYPE_FIELD_DESC = new thrift.TField("list_type", thrift.TType.LIST, 1);
  static final thrift.TField _SET_TYPE_FIELD_DESC = new thrift.TField("set_type", thrift.TType.SET, 2);

  List<int> _list_type;
  static const int LIST_TYPE = 1;
  Set<int> _set_type;
  static const int SET_TYPE = 2;


  underlying_types_test_args() {
  }

  List<int> get list_type => this._list_type;

  set list_type(List<int> list_type) {
    this._list_type = list_type;
  }

  bool isSetList_type() => this.list_type != null;

  unsetList_type() {
    this.list_type = null;
  }

  Set<int> get set_type => this._set_type;

  set set_type(Set<int> set_type) {
    this._set_type = set_type;
  }

  bool isSetSet_type() => this.set_type != null;

  unsetSet_type() {
    this.set_type = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case LIST_TYPE:
        return this.list_type;
      case SET_TYPE:
        return this.set_type;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case LIST_TYPE:
        if(value == null) {
          unsetList_type();
        } else {
          this.list_type = value as List<int>;
        }
        break;

      case SET_TYPE:
        if(value == null) {
          unsetSet_type();
        } else {
          this.set_type = value as Set<int>;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case LIST_TYPE:
        return isSetList_type();
      case SET_TYPE:
        return isSetSet_type();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case LIST_TYPE:
          if(field.type == thrift.TType.LIST) {
            thrift.TList elem60 = iprot.readListBegin();
            list_type = new List<int>();
            for(int elem62 = 0; elem62 < elem60.length; ++elem62) {
              int elem61 = iprot.readI64();
              list_type.add(elem61);
            }
            iprot.readListEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SET_TYPE:
          if(field.type == thrift.TType.SET) {
            thrift.TSet elem63 = iprot.readSetBegin();
            set_type = new Set<int>();
            for(int elem65 = 0; elem65 < elem63.length; ++elem65) {
              int elem64 = iprot.readI64();
              set_type.add(elem64);
            }
            iprot.readSetEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(this.list_type != null) {
      oprot.writeFieldBegin(_LIST_TYPE_FIELD_DESC);
      oprot.writeListBegin(new thrift.TList(thrift.TType.I64, list_type.length));
      for(var elem66 in list_type) {
        oprot.writeI64(elem66);
      }
      oprot.writeListEnd();
      oprot.writeFieldEnd();
    }
    if(this.set_type != null) {
      oprot.writeFieldBegin(_SET_TYPE_FIELD_DESC);
      oprot.writeSetBegin(new thrift.TSet(thrift.TType.I64, set_type.length));
      for(var elem67 in set_type) {
        oprot.writeI64(elem67);
      }
      oprot.writeSetEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("underlying_types_test_args(");

    ret.write("list_type:");
    if(this.list_type == null) {
      ret.write("null");
    } else {
      ret.write(this.list_type);
    }

    ret.write(", ");
    ret.write("set_type:");
    if(this.set_type == null) {
      ret.write("null");
    } else {
      ret.write(this.set_type);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is underlying_types_test_args)) {
      return false;
    }
    underlying_types_test_args other = o as underlying_types_test_args;
    return this.list_type == other.list_type
      && this.set_type == other.set_type;
  }

  underlying_types_test_args clone({
    List<int> list_type: null,
    Set<int> set_type: null,
  }) {
    return new underlying_types_test_args()
      ..list_type = list_type ?? this.list_type
      ..set_type = set_type ?? this.set_type;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class underlying_types_test_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("underlying_types_test_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.LIST, 0);

  List<int> _success;
  static const int SUCCESS = 0;


  underlying_types_test_result() {
  }

  List<int> get success => this._success;

  set success(List<int> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as List<int>;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.LIST) {
            thrift.TList elem68 = iprot.readListBegin();
            success = new List<int>();
            for(int elem70 = 0; elem70 < elem68.length; ++elem70) {
              int elem69 = iprot.readI64();
              success.add(elem69);
            }
            iprot.readListEnd();
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeListBegin(new thrift.TList(thrift.TType.I64, success.length));
      for(var elem71 in success) {
        oprot.writeI64(elem71);
      }
      oprot.writeListEnd();
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("underlying_types_test_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      if(this.success == null) {
        ret.write("null");
      } else {
        ret.write(this.success);
      }
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is underlying_types_test_result)) {
      return false;
    }
    underlying_types_test_result other = o as underlying_types_test_result;
    return this.success == other.success;
  }

  underlying_types_test_result clone({
    List<int> success: null,
  }) {
    return new underlying_types_test_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class getThing_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("getThing_args");



  getThing_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getThing_args(");

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is getThing_args)) {
      return false;
    }
    return true;
  }

  getThing_args clone() {
    return new getThing_args();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class getThing_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("getThing_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.STRUCT, 0);

  t_validStructs.Thing _success;
  static const int SUCCESS = 0;


  getThing_result() {
  }

  t_validStructs.Thing get success => this._success;

  set success(t_validStructs.Thing success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_validStructs.Thing;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.STRUCT) {
            success = new t_validStructs.Thing();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getThing_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      if(this.success == null) {
        ret.write("null");
      } else {
        ret.write(this.success);
      }
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is getThing_result)) {
      return false;
    }
    getThing_result other = o as getThing_result;
    return this.success == other.success;
  }

  getThing_result clone({
    t_validStructs.Thing success: null,
  }) {
    return new getThing_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class getMyInt_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("getMyInt_args");



  getMyInt_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMyInt_args(");

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is getMyInt_args)) {
      return false;
    }
    return true;
  }

  getMyInt_args clone() {
    return new getMyInt_args();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class getMyInt_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("getMyInt_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.I32, 0);

  int _success;
  static const int SUCCESS = 0;

  bool __isset_success = false;

  getMyInt_result() {
  }

  int get success => this._success;

  set success(int success) {
    this._success = success;
    this.__isset_success = true;
  }

  bool isSetSuccess() => this.__isset_success;

  unsetSuccess() {
    this.__isset_success = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as int;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.I32) {
            success = iprot.readI32();
            this.__isset_success = true;
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeI32(success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMyInt_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is getMyInt_result)) {
      return false;
    }
    getMyInt_result other = o as getMyInt_result;
    return this.success == other.success;
  }

  getMyInt_result clone({
    int success: null,
  }) {
    return new getMyInt_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class use_subdir_struct_args implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("use_subdir_struct_args");
  static final thrift.TField _A_FIELD_DESC = new thrift.TField("a", thrift.TType.STRUCT, 1);

  t_subdir_include_ns.A _a;
  static const int A = 1;


  use_subdir_struct_args() {
  }

  t_subdir_include_ns.A get a => this._a;

  set a(t_subdir_include_ns.A a) {
    this._a = a;
  }

  bool isSetA() => this.a != null;

  unsetA() {
    this.a = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case A:
        return this.a;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case A:
        if(value == null) {
          unsetA();
        } else {
          this.a = value as t_subdir_include_ns.A;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case A:
        return isSetA();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case A:
          if(field.type == thrift.TType.STRUCT) {
            a = new t_subdir_include_ns.A();
            a.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(this.a != null) {
      oprot.writeFieldBegin(_A_FIELD_DESC);
      a.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("use_subdir_struct_args(");

    ret.write("a:");
    if(this.a == null) {
      ret.write("null");
    } else {
      ret.write(this.a);
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is use_subdir_struct_args)) {
      return false;
    }
    use_subdir_struct_args other = o as use_subdir_struct_args;
    return this.a == other.a;
  }

  use_subdir_struct_args clone({
    t_subdir_include_ns.A a: null,
  }) {
    return new use_subdir_struct_args()
      ..a = a ?? this.a;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
class use_subdir_struct_result implements thrift.TBase {
  static final thrift.TStruct _STRUCT_DESC = new thrift.TStruct("use_subdir_struct_result");
  static final thrift.TField _SUCCESS_FIELD_DESC = new thrift.TField("success", thrift.TType.STRUCT, 0);

  t_subdir_include_ns.A _success;
  static const int SUCCESS = 0;


  use_subdir_struct_result() {
  }

  t_subdir_include_ns.A get success => this._success;

  set success(t_subdir_include_ns.A success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch(fieldID) {
      case SUCCESS:
        if(value == null) {
          unsetSuccess();
        } else {
          this.success = value as t_subdir_include_ns.A;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if the field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch(fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(thrift.TProtocol iprot) {
    thrift.TField field;
    iprot.readStructBegin();
    while(true) {
      field = iprot.readFieldBegin();
      if(field.type == thrift.TType.STOP) {
        break;
      }
      switch(field.id) {
        case SUCCESS:
          if(field.type == thrift.TType.STRUCT) {
            success = new t_subdir_include_ns.A();
            success.read(iprot);
          } else {
            thrift.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          thrift.TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(thrift.TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if(isSetSuccess() && this.success != null) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("use_subdir_struct_result(");

    if(isSetSuccess()) {
      ret.write("success:");
      if(this.success == null) {
        ret.write("null");
      } else {
        ret.write(this.success);
      }
    }

    ret.write(")");

    return ret.toString();
  }

  bool operator ==(Object o) {
    if(o == null || !(o is use_subdir_struct_result)) {
      return false;
    }
    use_subdir_struct_result other = o as use_subdir_struct_result;
    return this.success == other.success;
  }

  use_subdir_struct_result clone({
    t_subdir_include_ns.A success: null,
  }) {
    return new use_subdir_struct_result()
      ..success = success ?? this.success;
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
